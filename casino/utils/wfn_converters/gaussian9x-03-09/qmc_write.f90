SUBROUTINE qmc_write
!-------------------------------------------------------------!
! Output the wave function obtained from the .Fchk and .out   !
! files in CASINO standard gwfn.data format.                  !
!-------------------------------------------------------------!
 USE awk_like
 USE cis_data
 USE g94_wavefunction
 IMPLICIT NONE
 INTEGER,PARAMETER :: Num_dft=13

 INTEGER i,iband,icoeff,ifun,iocc,ispin,iname,idet
 INTEGER ilook, iscan,ifunc ! for parsing job/calculation type
 INTEGER Num_centres ! number of unique shell centres
 INTEGER ifirst_shll(Nshells+1) ! index of the first shell at each unique centre
 INTEGER icheck ! flag for error checking on IO operations
 INTEGER ivirt  ! indexes the resummed excited state determinants
                ! and thus the resummed MO used to create each
 INTEGER ndet_out ! No. of det.'s in CIS expansion to output
! ishll_type() holds the identity of each shell in the form
! used in CASINO:
! s=1, sp=2, p=3, d= 4, f= 5 etc.. (harmonic representation)
!                 d=-4, f=-5       (cartesian representation)
 INTEGER ishll_type(Nshells)

 REAL(KIND=dp) ck(100) ! Holds orbital coeffs in the order required by CASINO
 LOGICAL scan ! Use to control scanning of external files
 LOGICAL dftcalc ! .true. if Gaussian calc. was a DFT calc.
 CHARACTER(13),PARAMETER :: reals3="(3(1PE20.13))"
 CHARACTER(13),PARAMETER :: reals4="(4(1PE20.13))"
 CHARACTER(13),PARAMETER :: int8="(8I10)"
! dft holds the strings that must occur in the job description
! if a DFT job is being performed
 CHARACTER(5) dft(Num_dft)
 CHARACTER(15) mthd ! Holds the bit of string that identifies the type of calc.
 CHARACTER(34) filenames(2) ! G94 job and output filenames
 CHARACTER(130) line_input ! Use for copying lines of external files

 write(6,fmt="(/'Writing QMC wave function to ',a)")trim(g94_file)//'.qmc'

 open(unit=22,file=trim(g94_file)//'.qmc',status='unknown')

 dft=(/"LSDA ","LDA  ","VWN  ","LYP  ","PL   ","P86  ","PW91 ", &
       &"BECKE","B3P  ","SP81 ","M06  ","M05  ","M08  "/)

!=================Title Section==================================
 write(22,fmt=*)trim(title_txt)

!=================Basic Information==============================

 write(22,fmt="(/'BASIC_INFO'/'----------')")

 write(22,fmt="('Generated by:'/A32)")code_used

! Work out whether we are doing a density functional calc.
 call scan_string(job_txt,fields,NF,NF_max," ")
 mthd=trim(fields(2))

 call capitalise(mthd,len(mthd))

 dftcalc=.false.
 do ilook=1,Num_dft
  iscan=index(string=mthd,substring=trim(dft(ilook)))
  if(iscan/=0)then
   dftcalc=.true.
   ifunc=iscan
   exit
  endif
 enddo

 write(22,fmt="('Method:')")
 write(22,fmt="(A11)")mthd
 write(22,fmt="('DFT Functional:')")
 if(dftcalc)then
! mthd will not just hold the functional at the moment - it may
! also hold more stuff about the calculation so try and
! remove it - assumes such bits are separated by hyphens.
  call scan_string(mthd(ifunc:len(mthd)),fields,NF,NF_max,"-")
  write(22,*)trim(fields(1))
 else
  write(22,fmt="('none')")
 endif

 write(22,fmt="('Periodicity:'/'0')")

 write(22,fmt="('Spin unrestricted:')")
 if(spin)then
  write(22,fmt="('.true.')")
 else
  write(22,fmt="('.false.')")
 endif

 write(22,fmt="('nuclear-nuclear repulsion energy (au/atom):')")
 write(22,*)Eionion

 write(22,fmt="('Number of electrons per primitive cell:')")
 write(22,*)Nelec

!=================Geometry input=======================================

 write(22,fmt="(/'GEOMETRY'/'--------')")

 write(22,fmt="('Number of atoms:')")
 write(22,*)Natom

 write(22,fmt="('Atomic positions (au):')")
 write(22,fmt=reals3)atom_posn

 write(22,fmt="('Atomic numbers for each atom:')")
 write(22,fmt=int8)Natomic_no

 write(22,fmt="('Valence charges for each atom:')")
 write(22,fmt=reals4)atomic_chrg

!=================Basis set==============================================

 write(22,fmt="(/'BASIS SET'/'---------')")

! Identify how many unique shell centres we have and the index of
! the first shell at each such centre
 call shell_centres(Num_centres,ifirst_shll)

 write(22,fmt="('Number of Gaussian centres')")
 write(22,*)Num_centres

 write(22,fmt="('Number of shells per primitive cell')")
 write(22,*)Nshells

! If Ncoeffs /= Nmo then we create some fake MOs when we write out the
! eigenvectors in order to keep CASINO happy.
 write(22,fmt="('Number of basis functions (''AO'') per primitive cell')")
 write(22,*)Ncoeffs

 write(22,fmt="('Number of Gaussian primitives per primitive cell')")
 write(22,*)Nprimgtf

! Have to shift Gaussian94's value for this since L=0,1,2 for s,p,d in
! that program and CASINO expects L=1 for s etc. etc.
 write(22,fmt="('Highest shell angular momentum (s/p/d/f... 1/2/3/4...)')")
 write(22,*)max_AM+1

! Convert from Gaussian94 shell types to QMC notation:
 do i=1,Nshells

  shell_type: select case(abs(Lshell(i)) )

   case(0) ! S shell
    ishll_type(i)=1
   case(1) ! SP or P shell
    if(Lshell(i)==-1)then
     ishll_type(i)=2 ! SP shell
    else
     ishll_type(i)=3 ! P shell
    endif
   case(2) ! D shell - harmonic if -ve, cartesian if +ve but needs to  be
           ! the other way around for CASINO
    ishll_type(i)=-sign(4,Lshell(i))
   case(3) ! F shell
    ishll_type(i)=-sign(5,Lshell(i))
   case(4) ! G shell
    ishll_type(i)=-sign(6,Lshell(i))
   case(5) ! H shell
    ishll_type(i)=-sign(7,Lshell(i))
   case(6) ! I shell
    ishll_type(i)=-sign(8,Lshell(i))
   case default
    write(*,fmt="('Error in qmc_write: shell type is not supported, &
     &Lshell = ',I2)") Lshell(i)

  end select shell_type

 enddo

 write(22,fmt="('Code for shell types (s/sp/p/d/f... 1/2/3/4/5...)')")
 write(22,fmt=int8)ishll_type

 write(22,fmt="('Number of primitive Gaussians in each shell')")
 write(22,fmt=int8)Nprim

 write(22,fmt="('Sequence number of first shell on each centre')")
 write(22,fmt=int8)ifirst_shll(1:Num_centres+1)

 write(22,fmt="('Exponents of Gaussian primitives')")
 write(22,fmt=reals4)shexpnt

 write(22,fmt="('Normalized contraction coefficients')")
 write(22,fmt=reals4)c_prim

 if(num_sp>0)then
  write(22,fmt="('2nd contraction coefficients (p coeff. for sp shells,&
   & 0 otherwise)')")
  write(22,fmt=reals4)c2_prim
 endif

 write(22,fmt="('Position of each shell (au)')")
 write(22,fmt=reals3)shll_posn

!=================Multideterminant information============================

 write(22,fmt="(/'MULTIDETERMINANT INFORMATION'/&
  &'----------------------------')")
 if(CAS)then
  call cas_write(22)
 elseif(icis_out==0)then
  write(22,fmt="('GS')")
 else
  if(resummed)then ! RESUMMED CIS/TD-DFT wave function...
   Ndet_out=sum(Ndet(1:ispin_lim)) ! Number of determinants in expansion
   if(.not.SPIN)Ndet_out=2*Ndet_out
   if(Ndet_out>1)then
    write(22,fmt="('MD')")
    write(22,*)Ndet_out
   else
    write(22,fmt="('SD')")
   endif

! If we have a spin-restricted wave function then we need two
! determinants per excitation in order to construct a true spin
! state.  We therefore have twice as many determinants and hence
! twice as many coefficients
   if(SPIN)then ! Spin-unrestricted case

    if(ndet_out>1)then
! Coefficients of the determinants -  the CIS expansion
! coefficients are all included in the eigenvector coefficients
! due to the resumming process so we just need some '1's here
     do ispin=1,ispin_lim
      do i=1,Ndet(ispin)
       write(22,*)1.d0
      enddo
     enddo
    endif

! Corresponding alpha then beta excited state determinants
    idet=0  ! Counts determinants
    do ispin=1,ispin_lim
     ivirt=0 ! Count of the effective (resummed) virtual orbitals
             ! must be reset for different spins
     do iocc=1,Nspin(ispin)

      if(Npromote(iocc,ispin)>0)then
       ivirt=ivirt+1 ! Next resummed orbital of spin ispin
       idet=idet+1 ! Next excited determinant
! Promote electron in band iocc, k-point 1, to band
! ivirt+Nspin(ispin) (ivirt is shift above occupied bands),
! kpoint 1, in determinant ivirt, spin ispin.  ivirt essentially
! counts the no. of (resummed) determinants
       write(22,fmt="('DET ',i3,1x,i1,1x,'PR',2(1x,i3,1x,i1))") &
        &idet,ispin,iocc,1,ivirt+Nspin(ispin),1
      endif
     enddo
    enddo

   else ! Spin-restricted case

    if(ndet_out>1)then
     if(singlet)then
! Coefficients of the determinants - again, all unity because of resumming.
      do i=1,Ndet_out
       write(22,*)1.d0
      enddo
     else
      do i=1,(Ndet_out/2)
! Triplet is spin-down excitation minus spin-up excitation
       write(22,*)1.d0
       write(22,*)-1.d0
      enddo
     endif
    endif

! This is a spin-restricted calculation and therefore we have to
! construct pure spin states
    ivirt=0
    idet=0  ! Counts determinants
    do iocc=1,Nspin(1)

     if(Npromote(iocc,1)>0)then
      ivirt=ivirt+1
      if(singlet)then ! Construct a spin-singlet excitation
       idet=idet+1
       write(22,fmt="('DET ',i3,1x,i1,1x,'PR',2(1x,i3,1x,i1))") &
        &idet,1,iocc,1,ivirt+Nspin(1),1
       idet=idet+1
       write(22,fmt="('DET ',i3,1x,i1,1x,'PR',2(1x,i3,1x,i1))") &
        &idet,2,iocc,1,ivirt+Nspin(1),1
      ELSE ! Construct a spin-triplet excitation
! Sz=0 (two-determinant form) triplet - legal for constructing an
! excitation from a ground state with Sz=0
       idet=idet+1
       write(22,fmt="('DET ',i3,1x,i1,1x,'PR',2(1x,i3,1x,i1))") &
        &idet,2,iocc,1,ivirt+Nspin(1),1
       idet=idet+1
       write(22,fmt="('DET ',i3,1x,i1,1x,'PR',2(1x,i3,1x,i1))") &
        &idet,1,iocc,1,ivirt+Nspin(1),1
! This bit for an Sz=-1 triplet wave function (which has half as many
! determinants as the Sz=0 form).
!      write(22,fmt="('DET ',i3,1x,i1,1x,'MI',1x,i3,1x,i1)") &
!       &ivirt,1,iocc,1
!      write(22,fmt="('DET ',I3,1x,I1,1x,'PL',1x,i3,1x,i1)") &
!       &ivirt,2,(ivirt+Nspin(1)),1
      endif
     endif
    enddo
   endif

  else  ! Excited state expansion has NOT been resummed

! If we have a spin-restricted wave function then can construct
! a spin eigenstate and thus have twice as many determinants
! and hence twice as many coefficients
   if(.not.SPIN)then
    Ndet_out=2*sum(Nconfig(1:ispin_lim))
   else
    Ndet_out=sum(Nconfig(1:ispin_lim))
   endif

   if(Ndet_out>1)then
    write(22,fmt="('MD')")
    write(22,*)Ndet_out

! CIS expansion coeffs for the alpha (ispin=1) and beta (ispin=2) excitations.
    do ispin=1,ispin_lim,1
     do i=1,Nconfig(ispin),1
      write(22,*)ci_coeff(i,ispin)
      if(.not.SPIN)then
       if(singlet)then
! Each singlet is constructed from an alpha and a beta
! excitation, each share the same expansion coefficient
        write(22,*) ci_coeff(i,ispin)
       else
! Similarly for the triplet except that it is formed
! from a spin-down excitation MINUS a spin-up
        write(22,*)-ci_coeff(i,ispin)
       endif
      endif
     enddo
    enddo

   else
    write(22,fmt="('SD')")
   endif

   if(SPIN)then
! Corresponding definitions of the alpha & beta excited states
    idet=0
    do ispin=1,ispin_lim
     do i=1,Nconfig(ispin)
      idet=idet+1
      write(22,fmt="('DET ',i3,1x,i1,1x,'PR',2(1x,i3,1x,i1))")idet,ispin, &
       &Orbitals(1,i,ispin),1,Orbitals(2,i,ispin),1
     enddo
    enddo
   else
! This is a spin-restricted calculation and therefore we have to
! construct pure spin states.  A spin restricted calc. is stored
! as an alpha state here so ispin has been set to 1 below.

    idet = 0
    do i=1,Nconfig(1)
     iocc=Orbitals(1,i,1)
     ivirt=Orbitals(2,i,1)
     if(singlet)then ! Construct a singlet state
      idet=idet+1
      write(22,fmt="('DET ',i3,1x,i1,1x,'PR',2(1x,i3,1x,i1))") idet,1, &
       &iocc,1,ivirt,1
      idet=idet+1
      write(22,fmt="('DET ',i3,1x,i1,1x,'PR',2(1x,i3,1x,i1))") idet,2, &
       &iocc,1,ivirt,1
     else ! Construct a triplet state
! Sz=0 triplet state
      idet=idet+1
      write(22,fmt="('DET ',i3,1x,i1,1x,'PR',2(1x,i3,1x,i1))") &
       &idet,2,iocc,1,ivirt,1
      idet=idet+1
      write(22,fmt="('DET ',i3,1x,i1,1x,'PR',2(1x,i3,1x,i1))") &
       &idet,1,iocc,1,ivirt,1
! Sz=-1 triplet state
!     write(22,fmt="('DET ',i3,1x,i1,1x,'MI',1x,i3,1x,i1)")i,1,iocc,1
!     write(22,fmt="('DET ',i3,1x,i1,1x,'PL',1x,i3,1x,i1)")i,2,ivirt,1
     endif
    enddo
   endif

  endif
! The no. of up- and down-spin electrons specified in 'input' will have
! to be modified if we're constructing an Sz!=0 triplet state
! if((.not.SPIN).and.(.not. singlet))then
!  write(6,fmt="(/'******************************************************&
!   &********************'/&
!   &'WARNING: you must set NEU=',I3,' and NED=',I3,' in the&
!   & CASINO ''input'' file in order'/'to run this calculation&
!   & correctly.'/&
!   &'******************************************************&
!   &********************')") (Nspin(1)-1),(Nspin(2)+1)
! endif
 endif

!=================Eigenvector components==================================

 write(22,fmt="(/'ORBITAL COEFFICIENTS'/'------------------------')")

 if(Nmo/=Ncoeffs)then
! In G98 Nmo is not always equal to Ncoeffs.  Since CASINO assumes
! that Nmo=Ncoeffs, we have to create some fake MOs to make up the
! difference. To do this, we copy the highest MO (no. Nmo) into the
! (Ncoeffs-Nmo) fake MOs.
  do ispin=1,ispin_lim
   do iband=(Nmo+1),Ncoeffs
    evcoeff1(1:Ncoeffs,iband,ispin)=evcoeff1(1:Ncoeffs,Nmo,ispin)
   enddo
  enddo
 endif

 icoeff=0
 do ispin=1,ispin_lim
  do iband=1,Ncoeffs
   do ifun=1,Ncoeffs
    icoeff=icoeff+1
    ck(icoeff)=evcoeff1(ifun,iband,ispin)
! write the eigenvector coefficients to the file, 100 at a time.
    if(icoeff==100)then
     icoeff=0
     write(22,fmt=reals4)ck
    endif
   enddo
  enddo
 enddo

! Allow for the fact that the total number of orbital coefficients will
! not in general be exactly divisible by 100 so we have some left...
 if(icoeff/=0)then
  write(22,fmt=reals4) ck(1:icoeff)
 endif

!====================Append any other info. to the input file===========

 write(22,fmt="(/'Job and output files for this calculation (not read &
  &by CASINO)')")
 write(22,fmt="('=====================================================&
  &===========================')")

! Files to append to the CASINO gwfn.data file
 filenames(1)=trim(g94_file)
 filenames(2)=trim(g94_file)//".out"

 do iname=1,2,1

! Open the file
  open(unit=23,file=filenames(iname),status='old',iostat=icheck)

  if(icheck>0)then
   write(*,fmt="('Cannot find the file: ',A30)")filenames(iname)
   write(22,fmt="('Could not find the file, ',A30)")filenames(iname)
  else
   write(22,*)
   scan=.true.
   do while(scan)

    read(23,fmt="(a130)",iostat=icheck)line_input

    if(icheck==0)then
     write(22,fmt=*)trim(line_input)
    elseif(icheck<0)then
     scan=.false.
    else
     write(*,fmt="('Error reading ',a30,' ...skipping.')")filenames(iname)
     scan=.false.
    endif

   enddo
  endif

  close(unit=23)

 enddo

 close(unit=22)

END SUBROUTINE qmc_write
